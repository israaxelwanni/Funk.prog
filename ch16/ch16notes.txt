16.2
non-overlapping functions = Patterns that do not rely on the order in which 
                            they are matched.

In order to simplify the process of reasoning about programs, 
it is good practice to use non-overlapping patterns whenever 
possible when defining functions

16.4
Haskell programs involve some form of recursion. Reasoning about such programs 
normally proceeds using the simple but powerful technique of induction.

data Nat = Zero | Succ Nat

add :: Nat -> Nat -> Nat
add Zero m = m
add (Succ n) m = Succ (add n m)

Example:
P(n) ::= add n Zero = n
for the property n we want to prove that add n Zero = n

base case: 
P(Zero) ::= add Zero Zero = Zero

add Zero Zero
v v v (apply add)
Zero

inductive case: 
P(n) => P(Succ(n)) = add n Zero = n => add (Succ n) Zero = Succ n

add (Succ (n)) Zero
v v v (Apply add)
Succ (add n Zero)
v v v (apply inducyion hypothesis: add n Zero = n)
Succ n

Example:
P(x) ::= add x (add y z) = add (add x y) z
(we take x because it occurs at the first position of the function, 
implying that it is the recursive variable)

Base case: 
P(Zero) ::= add Zero (add y z) = add (add Zero y) z

add Zero (add y z)
v v v (Apply outer add)
add y z
v v v (unapplying (inner) add)
add (add Zero y) z

add (add Zero y) z
v v v (apply inner add)
add y z 
v v v (unapplying (outer) add)
add Zero (add y z)

inductive case: 
(Start with the property that looks the most complicated)
P(x) => P(Succ x) ::= 
add x (add y z) = add (add x y) z => add (Succ x) (add y z) = add (add (Succ x) y) z

add (Succ x) (add y z)
v v v (apply outer add)
Succ (add x (add y z))
v v v (apply induction hypothesis: add x (add y z) = add (add x y) z)
Succ (add (add x y) z)
v v v (unapply outer add)
add (Succ (add x y)) z
v v v  (unnapply inner add)
add (add (Succ x) y) z

16.5

Base cases for inductive proof on lists is the property with the empty list and 
the inductive case is the property with the non-empty list.
P(xs) -> P([]) & P(xs) => P(x:xs)

Example:

rev :: [a] -> [a]
rev [] = []
rev (x:xs) = rev xs ++ [x]

show that:
rev (rev xs) = xs

Base case: 
P([]) ::= rev (rev []) = []

rev (rev [])
v v v (apply inner rev)
rev []
v v v (apply rev)
[]

inductive case:
P(xs) => P(x:xs) ::= rev (rev xs) = xs => rev (rev (x:xs)) = x:xs

rev (rev (x:xs))
v v v (apply inner rev)
rev (rev xs ++ [x])
v v v (distributivity-lemma*)
rev [x] ++ rev (rev xs)
v v v (rev of a singleton is just the same singletion -> singleton-lemma*)
[x] ++ rev (rev xs)
v v v (apply inductive hypothesis)
[x] ++ xs
v v v (apply (++))
(x:xs)

distributivity-lemma*:
rev (xs ++ ys) = rev ys ++ rev xs

{singleton-lemma*
rev [x]
v v v (extend the singletion with :)
rev (x : [])
v v v (apply rev)
rev [] ++ [x]
v v v (apply rev)
[] ++ [x]
v v v (apply (++))
[x]
}

16.6

